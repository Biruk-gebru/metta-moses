;; Generate all possible combination of neighbors at a given distance.
;; Given a center instance, which is a list of numbers, we generate all
;;  variations of that instance at a specified distance.
;;
;; For example for a center instance of (0 0 0 1), a possible neighbor
;;  at distance 1 would be (0 0 0 0) or (0 0 1 1). The distance used is
;;  a hamming distance of bits.
;;
;; This specific function is a wrapper for the varyNKnobs function. It
;;  cleans the output of varyNknobs to be unqiue and remove the center
;;  instance occurrence from the result. It also handles type conversion for compatiblity.
;;
;; Params:
;;    (mkMultip $m) - The multiplicity of the knobs
;;    (mkInst (Cons $x $xs)) - The center instance. It doesn't handle Nil case because
;;                              it doesn't make sense to have an empty instance.
;;    $dist - The hamming distance from the center instance to search for neighbors
;;
;; Returns: List of instances.
(: generateAllInNeighborhood (-> Multiplicity Instance Number (List Instance)))
(= (generateAllInNeighborhood (mkMultip $m) (mkInst (Cons $x $xs)) $dist)
   (let $multips (genList 1 (- $m 1))
   (let $instExp (List.listToExpr (Cons $x $xs))
   (let $listNeighbors (collapse (let $neighbors (varyNKnobs $multips $instExp $dist)
                              (mkInst (pyExprToList $neighbors))))
   (let $uqListNeighbors (unique-atom $listNeighbors) (pyExprToList $uqListNeighbors))))))


;; This function returns a non deterministic list of instances at the given distance.
;; It's output isn't typed and also needs further preprocessing.
;; The function is never meant to be called on it's own but used in the generateAllInNeighborhood
;;  which will do the proper post processing.
;;
;; It takes the initial center instance and generates neighbors.
;; It then uses those generated neighbors as the next center
;;  instances to continue searching. Also it removes most of
;;  the center instances generated by it, it never removes the
;;  original center instance it was called with.
;;
;; Params:
;;   $mutlips: The possible bit values for each number in the instance. It is generated using the multiplicity of the knob. For example, for a discrete knob with 3 values, the $multips would be (1 2). The value 0 is encoded in the code it self so no need to include it in the list.
;;   $instExp: The center instance as an expression of numbers
;;   $dist: The hamming distance
;;
;; Returns: A non deterministic list of instances as an expression of numbers.
(: varyNKnobs (-> Expression Expression Number Expression))
(= (varyNKnobs $multips $instExp $dist)
    (if (== $dist 0)
        $instExp
        (let $cndInst (collapse (vary1Knobs $multips $instExp))
        (let $uqCndInst (unique-atom $cndInst)
        (let $neighbors (let
                            $nextCenter
                            (superpose $uqCndInst)
                            (varyNKnobs $multips $nextCenter (- $dist 1))
                        )
        (subtraction-atom $neighbors ($instExp)))))))

;; A helper function for the varyNKnobs function. This function simply generates all possible neighbors from a center instance at distance 1. It may include duplicate instances but that will be processed by the varyNKnobs function.
;; $multips: The possible bit values for each number in the instance.
;; $instExp: The center instance as an expression of numbers.
;;
;; Returns: A non deterministic list of instances as an expression of numbers.
(: vary1Knobs (-> Expression Expression Expression))
(= (vary1Knobs $multips ()) (empty))
(= (vary1Knobs $multips $instExp)
   (let $i (superpose $multips)
   (let ($h $t) (decons-atom $instExp)
     (superpose (
                  (let $a (if (== $i $x) 0 $i) (cons-atom $a $t))
                  (let $b (vary1Knobs $multips $t) (cons-atom $h $b)))))))

;; Computes the hamming distance between two instances.
;; Example: inst1: (0 0 0 1), inst2: (0 0 0 0) => distance: 1
;;          inst1: (0 1 0 1), inst2: (0 0 0 0) => distance: 2
(: distance (-> Expression Expression Number) )
(= (distance $inst1 $inst2)
   (if (~= (size-atom $inst1) (size-atom $inst2))
       (Error (Inst: $inst1 and Inst: $inst2) (Instances are not equal lenght))
   (if (== $inst1 ())
       0
       (let ($h1 $t1) (decons-atom $inst1)
       (let ($h2 $t2) (decons-atom $inst2)
          (+ (if (== $h1 $h2) 0 1) (distance $t1 $t2)))))))

(: distance (-> Instance Instance Number) )
(= (distance (mkInst Nil) (mkInst Nil)) 0)
(= (distance (mkInst (Cons $x $xs)) (mkInst (Cons $y $ys)))
      (+ (if (== $x $y) 0 1) (distance (mkInst $xs) (mkInst $ys))))
